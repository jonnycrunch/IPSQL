var app=function(){"use strict";function t(){}function e(t){return t()}function n(){return Object.create(null)}function o(t){t.forEach(e)}function r(t){return"function"==typeof t}function s(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}function a(t){t.parentNode.removeChild(t)}let i;function d(t){i=t}const u=[],f=[],c=[],h=[],l=Promise.resolve();let p=!1;function g(t){c.push(t)}let b=!1;const y=new Set;function m(){if(!b){b=!0;do{for(let t=0;t<u.length;t+=1){const e=u[t];d(e),$(e.$$)}for(d(null),u.length=0;f.length;)f.pop()();for(let t=0;t<c.length;t+=1){const e=c[t];y.has(e)||(y.add(e),e())}c.length=0}while(u.length);for(;h.length;)h.pop()();p=!1,b=!1,y.clear()}}function $(t){if(null!==t.fragment){t.update(),o(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(g)}}const w=new Set;function S(t,e){-1===t.$$.dirty[0]&&(u.push(t),p||(p=!0,l.then(m)),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function _(s,u,f,c,h,l,p=[-1]){const b=i;d(s);const y=u.props||{},$=s.$$={fragment:null,ctx:null,props:l,update:t,not_equal:h,bound:n(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(b?b.$$.context:[]),callbacks:n(),dirty:p,skip_bound:!1};let _=!1;if($.ctx=f?f(s,y,((t,e,...n)=>{const o=n.length?n[0]:e;return $.ctx&&h($.ctx[t],$.ctx[t]=o)&&(!$.skip_bound&&$.bound[t]&&$.bound[t](o),_&&S(s,t)),e})):[],$.update(),_=!0,o($.before_update),$.fragment=!!c&&c($.ctx),u.target){if(u.hydrate){const t=function(t){return Array.from(t.childNodes)}(u.target);$.fragment&&$.fragment.l(t),t.forEach(a)}else $.fragment&&$.fragment.c();u.intro&&((k=s.$$.fragment)&&k.i&&(w.delete(k),k.i(v))),function(t,n,s){const{fragment:a,on_mount:i,on_destroy:d,after_update:u}=t.$$;a&&a.m(n,s),g((()=>{const n=i.map(e).filter(r);d?d.push(...n):o(n),t.$$.on_mount=[]})),u.forEach(g)}(s,u.target,u.anchor),m()}var k,v;d(b)}function k(e){let n;return{c(){var t,e,o,r;t="how",n=document.createElement(t),n.innerHTML="<h1>How does IPSQL work?</h1> \n  <p>IPSQL is quite different from traditional databases.</p> \n  <p>A typical database will write to a file on a server you&#39;re running it on. But\n  that doesn&#39;t work so well for building distributed systems.</p> \n  <p>IPSQL produces <strong>blocks</strong>, which are just blobs of binary data\n  that are then referenced by <strong>hash address</strong>.</p> \n  <p>This means that you can store IPSQL data anywhere. File systems, S3, export files, CDN, browser storage,\n  p2p networks (IPFS), blockchains (Filecoin), call all be used to store and provide access to IPSQL databases. In fact, you can use any <strong>combination</strong> of these storage systems layered as you see fit.</p> \n  <p>Since data is addressed by a cryptrographic hash we don&#39;t even need to trust the data provider.</p> \n  <p>Traditional databases write &quot;pages&quot; to file formats on disc for each transaction. This gives you a guarantee when the transaction returns the data is safely on disc.</p> \n  <p>IPSQL is a functional transformation that takes the hash address of a <strong>database</strong> and a <strong>SQL statement</strong> as input and deterministically returns the <strong>hash address</strong> of a <strong>SQL proof</strong>.</p> \n  <p>A <strong>SQL proof</strong> describes the <strong>result</strong> of the SQL statement (if\n  there is one, there won&#39;t be for most writes), a <strong>Set</strong> of hash addresses required to perform\n  the proof, a <strong>Set</strong> of new hash addresses written by the proof, and the hash address of the\n  database after performing the proof.</p> \n  <p>Rather than just returning the desired query result, we also know the block addresses required to verify\n  the proof.</p> \n  <p>This means we can have untrusted parties hold the large amounts of data necessary to perform\n  arbitrary SQL queries. We then only need this small fraction of the database to verify the proof.</p> \n  <p>We can also query databases and store their results offline. When the database changes in the future\n  we can ask for the proof of our old query against the new database and we&#39;ll only need the <strong>delta</strong> between the prior proof and the new one.</p>",e=n,o="class",null==(r="svelte-1sseda6")?e.removeAttribute(o):e.getAttribute(o)!==r&&e.setAttribute(o,r)},m(t,e){!function(t,e,n){t.insertBefore(e,n||null)}(t,n,e)},p:t,i:t,o:t,d(t){t&&a(n)}}}return new class extends class{$destroy(){!function(t,e){const n=t.$$;null!==n.fragment&&(o(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}(this,1),this.$destroy=t}$on(t,e){const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}$set(t){var e;this.$$set&&(e=t,0!==Object.keys(e).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}{constructor(t){super(),_(this,t,null,k,s,{})}}({target:document.body})}();
//# sourceMappingURL=bundle.js.map
